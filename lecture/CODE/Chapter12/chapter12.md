[이진 덧셈기]
===================================================================================================================
* 덧셈밖에 못하는 컴퓨터
```
덧셈은 연산에 있어서 가장 기본이 되는 동작이므로, 컴퓨터를 만들려면 일단 숫자를 더하기 위해서는 무엇을 만들어야 하는지 알고 있어야만 합니다. 일단 덧셈을
할 수 있는 기계를 만들고 나면 컴퓨터가 수행하는 유일한 연산이 바로 덧셈이라는 사실을 아시게 될 것입니다. 따라서 덧셈을 가능하도록 만들 수 있다면 뺄셈,
곱셈, 나눗셈을 위한 것을 만들 수 있을 뿐만 아니라 모기지 상환 금액을 계산할 수도, 로켓을 화성으로 보낼 수도, 체스를 둘 수도, 전화 요금을 해킹할
수도 있습니다.
```

* 합 비트와 자리올림 비트
```
십진수와 이진수에서 중요한 차이점 중 하나는 이진수에서 두 수의 합이 만들어낼 수 있는 각 자릿수의 경우의 수가 훨씬 적다는 점입니다. :그림1:에서 볼 수
있듯이 두 이진수를 합할 때, 각 자릿수에서 일어날 수 있는 모든 경우의 수를 2개의 표로 정리할 수 있습니다.
```

* 상호 배제적 게이트
```
우선 :그림2:의 자리올림 비트에 대한 표는 AND 게이트로 구현할 수 있습니다. 하지만 이전까지 배운 게이트중에서 합 비트를 표현할 수 있는 게이트는
없었습니다. 하지만 이전에 배운 게이트의 조합으로 이를 표현할 수 있습니다. :그림3:과 같이 AND 게이트 2개, OR 게이트 1개, NOT 게이트 1개의 조합으로
:그림4:의 입력과 출력을 가지는 회로를 만들었습니다. 이는 합 비트를 표현할 수 있으며, 입력 A 혹은 B가 1인 경우에는 출력이 1이 되지만, 두 입력 모두가
1이 되는 경우에는 0이 되기 때문에 상호 배제적(Exclusive)인 OR 게이트, 짧게는 XOR 게이트라는 이름을 가지고 있습니다. 그리고 :그림5:와 같은 기호로
표시합니다.
```

* 반가산기
```
:그림6:은 '반가산기(Half Adder)'라는 이름이 붙은 온전한 이유가 있습니다. 분명히 이 가산기도 한 비트짜리 두 이진수를 더해서 합 비트와 자리올림 비트를
만들어 냅니다. 하지만 대부분의 이진수가 한 비트만으로 이루어진 것은 아닙니다. 반가산기의 단점은 바로 아랫자리에서 덧셈을 통해 올라온 자리올림을 처리할 수 
없다는 것입니다. 예를 들어, :그림7:과 같이 두 이진수의 합을 구한다고 가정했을 때 반가산기는 오른쪽의 가장 낮은 자릿수에만 사용할 수 있습니다. 1 더하기
1은 0, 자리올림 1이 됩니다. 두 번째 자리부터는 자리올림수가 있기 때문에 실질적으로 세 개의 이진수를 더해 나가야만 합니다. 즉, 이 후의 두 이진수의
덧셈은 이전 자릿수에서 올라온 자리 올림수가 같이 포함되어야 합니다.
```

* 전가산기
```
세 개의 이진수를 더하기 위해서 두 개의 반가산기와 하나의 OR 게이트를 사용하여 :그림7:과 같은 회로를 만들 수 있습니다. 이 회로를 이해하기 위해서는
첫 번째 반가산기 왼쪽에 있는 A와 B 입력부터 따라가 보는 것이 좋을 것 같습니다. 첫 번째 반가산기의 출력은 합(sum) 비트와 자리올림(carry)비트 입니다. 
더해진 값은 반드시 이전 자리에서 올라온 자리올림 비트와 더해져야 하므로, 두 번째 반가산기의 입력이 됩니다. 두 번째 반가산기에 나오는 합 비트가 최종적인
합이 됩니다. 첫 번째 반가산기와 두 번째 반가산기에서 각각 나오는 자리올림 비트는 OR 게이트를 통과하게 됩니다. 여기서도 반가산기가 사용되어야 하는 것이
아닌가 생각하실 수도 있겠습니다. 실제로 반가산기를 사용해도 잘 동작합니다. 하지만, 좀 더 생각해보면 두 반가산기에서 출력되는 두 자리올림수가 모두 1이
될 확률은 없다는 것을 알 수 있습니다. 따라서 이 경우에는 OR 게이트를 사용하는 것만으로도 충분합니다. XOR 게이트와 OR 게이트의 동작에 차이가 발생하는
경우는 두 입력이 모두 1인 경우인데, 이 회로에서는 이러한 경우가 발생하기 않기 때문입니다. 이러한 회로를 '전가산기(Full Adder)'라고 부르며 :그림8:과
같이 표시합니다.
```

* 덧셈기
```
전가산기를 8개 이어 붙인다면 :그림9:와 같은 회로가 될 것입니다. 맨 오른쪽부터 자리올림 입력에는 '0'을 입력하고 해당 자릿수의 합은 전구로 출력을 보내고,
자리올림 출력은 다음 전가산기의 자리올림 입력으로 들어간다면 손으로 이진수를 더하는 과정과 똑같다는 사실을 눈으로 확인하실 겁니다. 그리고 마지막 전가산기의
자리올림출력을 전구로 출력한다면 총 9비트의 경우의 수를 나타낼 수 있고, 간단히 이야기하면 합의 결과를 511까지 나타낼 수 있습니다. 합의 결과가 작다고
생각한다면 :그림10:처럼 마지막 전가산기의 자리올림 출력을 다른 덧셈기의 첫 번째 전가산기의 자리올림 입력으로 연결한다면 총 17비트의 경우의 수를 나타낼
수 있게 됩니다. 이제 '정말 이런 방식으로 컴퓨터가 숫자들을 더하는 거야?'라는 의구심을 가지실 수 있습니다. 기본적으로는 맞습니다. 하지만, 정확하지는 
않습니다. 첫 번째로 덧셈기는 우리가 만든 것보다 훨씬 더 빠르게 동작하도록 만들 수 있습니다. 우리가 만든 덧셈기를 살펴보면, 가장 아랫자리 수를 더해서 
만들어지는 자리올림이 그 다음 자리 덧셈을 할 때 입력되어야 하며, 마찬가지로 끝에서 두 번째 자리 덧셈의 결과로 나오는 자리올림 역시도 그 다음 자리 덧셈을
할 때 반드시 필요합니다. 그 뒤의 나머지 자리에서도 마찬가지입니다. 따라서 덧셈기의 속도는 전가산기의 처리 속도와 비트 수를 곱한 결과가 됩니다. 이런 
덧셈기를 자리 올림 전파(ripple carry)덧셈기라 합니다. 속도를 빠르게 만든 덧셈기들은 자리올림을 예상(look-ahead carry)하는 기능을 수행하는 추가
회로를 이용해서 속도를 높이는 방법을 사용합니다. 두 번째로 중요한 차이점은 컴퓨터는 더 이상 릴레이를 사용하지 않는다는 점입니다. 1930년대부터 만들어진 
최초의 디지털 컴퓨터는 릴레이를 사용하였으나 그 이후에는 진공관을 사용했으며, 오늘 날의 컴퓨터는 트랜지스터를 사용합니다. 컴퓨터에서 사용되는 트랜지스터는 
기본적으로 릴레이와 동작은 같지만, 비교하기 어려울 정도로 빠르고, 작고, 조용하고, 전력소모가 적으면서 저렴합니다.
```
