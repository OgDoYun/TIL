[그렇다면 뺄셈은 어떨까요?]
===================================================================================================================
* 간단한 트릭
```
덧셈과 뺄셈은 여러 측면에서 상호 보완적인 부분이 있으며 연산이 이루어지는 방법에서 약간 차이가 있습니다. 덧셈은 숫자의 가장 오른쪽, 가장 낮은 자리에서
왼쪽으로 순서대로 계산해 나가는 방법을 사용합니다. 각 자리에서 발생한 자리올림수를 다음 자리의 숫자들과 같이 더해야 하기 때문입니다. 뺄셈에서는 자리 올
림수(carry)가 발생하는 것이 아니라 빌림수(borrow)기 발생하며. 본질적으로 덧셈과는 이런저런 면에서 서로 다른 연산 방법을 가지고 있습니다. :그림1:과
같이 뺄셈을 빌림없는 계산을 하려면 10진수의 숫자중 가장 큰 숫자인 9를 사용하는 것입니다. 이와 같이 9로 이루어진 숫자 열에서 어떤 값을 뺀 결과를 9의
보수라고 부릅니다. 여기서는 176에 대한 9의 보수는 823이 되는 것입니다. 보수를 사용할 때 좋은 점은 빼는 수가 무엇이든 9의 보수를 사용하여 계산하면
빌림 과정이 필요하지 않다는 것입니다. :그림2:와 같이 253에 823을 더한 다음 등식을 성립시키기 위해서 1을 더하고나서 1000을 빼주면 됩니다. 그러면 
빌림없이 뺄셈을 잘 수행했습니다. 만일 :그림3:과 같이 빼는 수가 빼어지는 수보다 크다면 어떻게 될까요? 보통 위와 같은 문제를 보면 '음...빼는 수가
빼어지는 수보다 크니까, 두 수를 바꿔서 뺄셈을 하고 결과가 음수라는 걸 기억하면 되겠군.'하고 생각하실 겁니다. 하지만 :그림4:에서 확인되듯이 이전 방법이
먹혀 들어가지 않습니다. 923에서 1000을 빼야 하는데 이렇게 되면 빌림이 발생합니다. 대신에 앞에서 999를 더했으므로 999를 빼는 방법을 사용해 봅시다.
이를 보면 결과가 음수가 된다는 것을 알 수 있는데, 두 수를 바꾸어서 999에서 922를 빼야 하는 겁니다. 이와 같은 형태의 연산도 빌림이 사용되지는 않았으며,
결과는 우리가 예상했던 것과 같습니다. 이렇게 빌림이 발생하는 두 가지 경우의 뺄셈을 빌림이 발생하지 않게 계산했습니다.
```

* 더 간단한 이진수
```
십진수에서 뺄셈을 할 때 9로만 이루어진 숫자열에서 빼는 수를 뺐기 때문에 이를 9의 보수라 불렀습니다. 이진수에서는 1로만 이루어진 숫자열에서 빼는 수를 빼기
때문에 그 결과를 1의 보수라 부릅니다. 하지만 1의 보수를 계산하기 위하여 실제로 뺄셈을 할 필요는 없습니다. 1의 보수에서는 원래 0이었던 비트 값은 1이 되며,
1이었던 비트 값은 모두 0이 되기 때문입니다. 따라서 1의 보수를 이진수의 반대 값(negation) 혹은 역수(inverse)라 이야기합니다. :그림5:에서 보이듯이
이전에 보았던 수식을 이진수로 바꾸어 계산해도 똑같이 빌림없이 계산할 수 있습니다. 그럼 이번에는 빼는 수가 더 큰 경우에 대해서 생각해 보도록 합시다. 앞의
예에서 두 수를 바꾸어 빼기 문제를 만들면 :그림6:과 같습니다. 앞에서 보신 것과 같이, 빼는 수가 빼어지는 수보다 작다면 1을 더하고 1 0000 0000을 빼서
위와 동일한 결과를 얻을 수 있습니다. 하지만 이 경우에는 빌림없이 뺄 수가 없으므로, 그 대신 1111 1111에서 '빼는 수에 대한 1의 보수와 빼어지는 수의 합'
을 뺄셈하면 의도한 결과가 나오는 것을 확인할 수 있습니다. 이 과정은 모든 비트를 반전시켜도 동일한 결과를 얻을 수 있습니다.
```

* 오버플로/언더플로
```
이번에 만든 계산기는 덧셈과 뺄셈이 가능합니다. 하지만 제작의 편의성을 위해서 뺄셈에서 음수가 나오는 경우는 고려하지 않았습니다. 기존 덧셈기와 확연히 다른
점은 전구의 갯수입니다. 오른쪽의 8개의 전구는 연산의 결과를 나타내므로 기능상 동일한 역할을 합니다. 하지만, 9번째 전구는 '오버플로(overflow)/언더플
로(underflow)'라는 레이블이 붙어 있습니다. 이 전구는 연산의 결과가 여덟 개의 전구로는 정상적으로 표시될 수 없는 경우라는 것을 알려줍니다. 즉, 이 전구는
덧셈의 결과가 255보다 크거나(오버플로), 뺄셈의 결과가 음수인 경우(언더플로)에 불이 켜집니다. 뺄셈에서 결과가 음수가 되는 경우는 빼는 수가 빼어지는 수보다
큰 경우밖에 없습니다.
```

* 뺄셈을 위한 덧셈기
```
이전까지의 연산방법을 적용한 덧셈기를 도식화해보면 :그림7:과 같습니다. SUB라는 이름이 붙어있는 세 개의 신호를 확인해보면, 덧셈과 뺄셈을 선택하는 스위치라는
것을 알 수 있습니다. 이 신호가 0인 경우에는 덧셈을 수행하게 되고 1인 경우에는 뺄셈을 수행하는 것입니다. 뺄셈이 수행되는 경우 B입력은 1의 보수를 만드는
회로를 통하여 덧셈기에 들어가기 전에 모든 비트가 반전됩니다. 이와 더불어, 앞에서 살펴보신 것과 같이 뺄셈을 처리할 때 마지막에 덧셈의 결과에 1을 더하는
부분을 처리하기 위해서 덧셈기의 CI(Carry In, 자리올림 입력)입력에 1을 입력시켜줍니다. 덧셈을 처리하는 동안에 1의 보수를 처리하는 회로에서는 아무런 일을
처리하지 않으며, CI 입력도 0이 됩니다. SUB 신호와 덧셈기의 CO(Carry Out, 자리올림 출력)출력은 XOR 게이트의 입력으로 연결되어 있으며, 이 출력은
오버/언더플로로 전구에 불이 들어오게 하는 데 사용됩니다. SUB 신호가 0이라면(덧셈 연산이 수행 중) 덧셈기의 CO출력이 1인 경우 전구에 불이 들어오게 됩니다.
이 말은 덧셈의 결과가 255보다 크다는 말이 됩니다. 뺄셈에서 빼는 수(B입력)가 빼어지는 수(A입력)보다 작은 경우에는 덧셈기의 CO 출력으로 1이 출력됩니다.
이는 뺄셈의 마지막 단계에서 1 0000 0000이 빼어져야 함을 의미하므로 당연한 것입니다. 따라서 오버/언더플로를 나타내는 전구는 덧셈기의 CO 출력이 0인 경우에
불이 들어와야 합니다. 하지만, 이런 경우는 빼는 수가 빼어지는 수보다 커져서 결과가 음수가 되는 경우밖에 없는데, 앞에서 이런 경우에 대해서는 생각하지 않는다고
했으니 뺄셈을 수행하는동안 이 전구에 불이 들어올 일은 없습니다.
```

* 음수의 표현
```
십진수에서 음수의 표현에 사용하는 방법은 숫자 앞에 음수 기호(-)를 적어주는 방법입니다. 하지만 이진수를 사용할 때 음수 기호를 포함한 모든 것을 0과 1로만
표현하는 것이 궁극적인 취지였습니다. 물론 음수 기호를 위하여 한 비트를 추가하는 방법을 사용할 수 있습니다. 즉, 한 비트를 더 두어서 1인 경우 음수를, 0인
경우 양수를 표현하게 할 수 있습니다. 이 방법이 충분히 많이 바뀐 것은 아니지만 표기하는 데 문제는 없습니다. 앞서 설명된 방법 이외에 음수를 표현하는 또 다른
방법이 있는데, 이 방법은 양수와 음수를 같은 방법으로 더할 수 있기 때문에 상당히 편리한 방법입니다. 하지만 이 방법은 숫자를 표현하기 위해서 얼마나 많은 비트를
사용할 것인지 미리 결정해 두어야 한다는 단점이 있습니다. 이런 부분이 단점이긴 하지만 우리는 일상적으로도 숫자를 사용할 때 무한한 숫자를 미리 알고 사용하지
않습니다. '0'부터 음의 방향, 양의 방향으로 필요에 따라 그 영역을 늘리면서 사용합니다. 예를 들면 8비트는 256의 경우의 수를 가지고 있습니다. '0'과 양의
정수를 이진수에 대응하여 그대로 쓰면, 그 나머지 128개의 경우의 수가 있습니다. 이를 음의 정수로 표현한다면 :그림8:과 같은 경우의 수를 생각해볼 수 있습니다.
이 숫자들이 원형으로 늘어진 형태를 가지고 있다는 것에 관심을 가지실 필요가 있습니다. 가장 작은 음수(-128)는 가장 큰 양수(127)와 연결되어 있는 것처럼
보입니다. 음수를 표현하고 싶다면 1로 시작하는 8비트숫자들을 이용하여 표현하면 됩니다. 이는 가장 왼쪽에 있는 비트(MSB, most significant bit)로 부호
비트라 이야기 합니다. 이 비트가 1이 되면 음수를 나타내고 0인 경우에는 양수를 나타냅니다. 2의 보수를 계산하기 위해서는 우선 1의 보수를 구하고 그 결과에 1을
더하면 됩니다. 이는 모든 비트를 반전시킨 후에 1을 더하는 것과 동일합니다. 예를 들어, 십진수 125는 0111 1101 입니다. 2의 보수를 이용하여 -125를 표현하
려면 일단 0111 1101 의 모든 비트를 반전시켜 1000 0010으로 만들고, 그 다음 1을 더해서 1000 0011을 만듭니다. 이 결과는 앞에서 보신 :그림8:을 통해
검증해 볼 수 있습니다. 다시 반대로 하더라도 마찬가지입니다. 즉, 모든 비트를 다시 반전시키고 1을 더하면 되는 겁니다. 이러한 시스템은 음수 기호를 따로 사용
하지 않으면서도 양수와 음수를 모두 표현할 수 있는 방법을 제공합니다. 게다가 덧셈의 규칙만을 이용하여 아주 간편하게 양수와 음수를 더할 수 있도록 해줍니다.
예를 들어 -127과 124에 해당하는 이진수들을 더하는 경우를 살펴보면 :그림9:에서 확인할 수 있듯이 그 결과는 십진수의 -3과 같은 값입니다. 여기서 오버플로와
언더플로를 발생시키는 조건에 대해서는 주의를 기울이실 필요가 있습니다. 즉, 덧셈의 결과가 127보다 커지는 경우 혹은 -128보다 작아지는 경우라 할 수 있습니다.
예를 들어, :그림10:처럼 125자신을 더하는 경우를 생각해보면 최상위 비트가 1이 되었으므로 이 결과는 음수로 해석될 수 있으며, 이진수로 나타난 수는 -6에 
해당합니다. 이와 비슷한 현상이 :그림11:처럼 -125끼리 더했을 때도 발생합니다. 8비트 숫자를 이용하겠다고 결정한 상태이기 때문에 가장 왼쪽의 비트는 무시되
어야 합니다. 따라서 남은 8비트의 값은 십진수 6과 동일합니다. 일반적으로 덧셈의 결과는 양수가 되거나 음수가 될 수 있지만, 같은 부호의 두 숫자를 더했을 때
다른 부호가 가진 결과가 나올 수는 없습니다. 따라서 이 두 결과는 오버플로와 언더플로에 해당하는 경우입니다. 지금까지 이진수를 사용하는 다른 두 가지 방법에
대해 배웠습니다. 즉, 이진수는 부호가 있는 숫자(signed)를 표현할 수 있고 부호가 없는(unsigned) 숫자를 표현할 수도 있습니다. 부호가 없는 8비트 숫자는
0에서 255까지의 범위를 가지고 있으며, 부호가 있는 8비트 숫자는 -128에서 127까지 표현할 수 있습니다. 하지만, 이진수 자체로는 해당 숫자가 부호가 있는
숫자인지, 부호가 없는 숫자인지 판단할 수 잇는 방법이 없습ㄴ디ㅏ. 예를 들어 "1011 0110이라는 8비트 숫자가 어떤 값을 가집니까? 10진수로는 어떻게 
나타낼 수 있겠습니까?"라는 질문에 대하여 "부호 있는 숫자입니까? 아니면 부호가 없는 숫자입니까? -74 혹은 182 모두 될 수 있습니다."라고 답할 수밖에
없습니다. 이러한 부분이 어찌 보면 비트의 사용의 어려움입니다. 비트는 0과 1만을 나타내며 그 자체로 어떤 것을 나타내는지는 알려주지 않기 때문입니다.
```